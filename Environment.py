from WebPage import *


class Environment:
    """Class containing all the informations that characterize the problem, from the classes of users to the list of available
       products. """

    def __init__(self, users: [User], products: [Product], n_arms, product_2_price):
        self.users = users
        self.n_arms = n_arms

        # List of available products: each of them has available the information of its position in the list -> attribute label
        self.products = products

        # Dict connecting to each product the position (with respect to the list of possible prices) of the chosen price
        self.product_2_price = product_2_price

    def execute(self, user, links, lambda_prob):
        """Method which simulates the entire interaction (considering even the case in which the user doesn't visit the website)
           of a user with our infrastructure. It returns the cumulative amount of margin generated by this interaction. """
        page_kind = user.start_event()
        if page_kind != 0:
            user.probabilities.loc[:, page_kind] = 0
            selected_price = self.product_2_price.get(self.products[page_kind].label)
            wp = WebPage(self.products[page_kind], user)
            return wp.interact(links, lambda_prob, selected_price)

    def simulate_day(self, users_number, users_probs, links, lambda_prob):
        """Method which simulates the usage of our website into an entire working day. Each day the alphas of each class of users
           are updated according to a Dirichlet distribution"""

        for user in self.users:
            user.update_alphas()

        daily_profit = 0
        for i in range(users_number):
            user_kind = np.random.multinomial(1, users_probs)
            probabilities = self.users[user_kind].probabilities.copy()

            # The class of the user is sampled from a multinomial depending on the known proportions
            daily_profit += self.execute(self.users[user_kind], links, lambda_prob)
            self.users[user_kind].restore(probabilities)

        self.update_prices()

    def update_prices(self):
        print(0)  # TODO: pensare a come effettuare l'aggiornamento dei pesi al termine di ciascuna giornata
