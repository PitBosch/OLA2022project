from UserCat import *
from Product import *


class Environment:
    """Class containing all the informations that characterize the problem, from the classes of users to the list of available
       products. """

    def __init__(self, users: list[UserCat], products: list[Product], lambda_q, Secondary_dict,
                 user_cat_prob):
        self.users = users
        # List of available products: each of them has available the information of its position in the list -> attribute label
        self.products = products
        # lambda_q is the parameter that determines how much the second secondary is less probable to be clicked
        self.lambda_q = lambda_q
        # dictionary of lists of secondary products
        self.Secondary_dict = Secondary_dict
        # relative frequency of the users category
        self.user_cat_prob = user_cat_prob # TODO:valutare se inserirlo come membro della classe userCat

    def execute(self, user, price_combination):
        """Method which simulates the entire interaction (considering even the case in which the user doesn't visit the website)
           of a user with our infrastructure. It returns the cumulative amount of margin generated by this interaction. """
        page_index = user.start_event()
        # è il draw dalla random choice per capire su che pagina attero tenendo in considerazione gli alpha
        if page_index != 5:
            user.empty_visited_products()
            #svuoto i prodotti visitati
            return self.user_profit(user,price_combination,page_index)
        return 0  #lo devo mettere perchè altrimenti restituisco NoneType quando page_index=5


    def simulate_day(self, users_number, users_probs, price_combination): #TODO USER PROBS DA TOGLIERE
        """Method which simulates the usage of our website into an entire working day. Each day the alphas of each class of users
           are updated according to a Dirichlet distribution, it takes as input number of users, user probability (that now will be
           inside usercat and the price combination of today"""

        for user in self.users:
            user.generate_alphas()
        #price_combination = []
        daily_profit = 0.
        for i in range(users_number):
            user_kind = np.random.choice([0, 1, 2], p=users_probs) #selezioniamo a quale categoria appartiene il nostro utente
            daily_profit += self.execute(self.users[user_kind], price_combination) #userprofit
        print(daily_profit)
            # TODO: aggiungere sistema per sviluppare l'ottimizzazione per ogni classe di utenti presa singolarmente (context generation)
        #self.update_prices() creiamo delle classi e l'update lo facciamo in ogni classe algoritmo

    def get_secondary(self, product: Product):
        """ Support method to retrieve the 2 secondary products associated to the given product"""
        secondary_list = []
        secondary_list.append(self.Secondary_dict[product])
        return secondary_list

    def exp_return(self, primary: Product, primary_history: set[Product], q_link, link, price_combination, user: UserCat):
        """ Method to compute the expected return for a singel product. The method is thought to give the priority to the 
            fist secondary product related to the primary product."""
        
        # first check if we have to stop the function, this is the case if:
        # primary is in primary_history --> the probability of the click is zero so the expected return
        # if not, add primary to the primary history  
         
        if primary in primary_history or primary.label == "null":
            return 0
        else:
            primary_history.add(primary)

        # retrieve price and margin for the primary product
        i = primary.label
        price = primary.get_daily_price(price_combination[i])
        margin = primary.get_daily_margin(price_combination[i])
        
        # compute b_i, i.e the probability to buy the primary product considered
        b_i = self.users.get_buy_prob(price)
        
        # compute expected margin
        exp_margin = margin * user.poisson_lambda  # margin * expected number of items bought, that is the poisson parameter

        # if both secondary items have been already seen we simply return the expected margin and go back to the link
        secondary_list = self.get_secondary(primary) 

        if secondary_list in primary_history:
            return b_i*exp_margin + q_link[-1] * self.exp_return(link[-1], primary_history, q_link[:-1], link[:-1], price_combination, user)

        # all exceptions have been treated, let's now compute the expected return in the basic cas
        
        # store the secondary and their labels
        s_1 = secondary_list[0]
        s_2 = secondary_list[1]
        
        j_1 = s_1.label
        j_2 = s_2.label

        # compute probabilities to click on the secondary given that the primary is bought
        q_1 = user.probabilities[i, j_1]
        q_2 = user.probabilities[i, j_2]*self.lambda_q

        return b_i*[exp_margin + q_1 * self.exp_return(s_1, primary_history, q_link.append(q_2), link.append(s_2), price_combination, user) +
                    (1-q_1) * q_2 * self.exp_return(s_2, primary_history, q_link, link, price_combination, user) +
                    (1-q_1) * (1-q_2) * q_link[-1] * self.exp_return(link[-1], primary_history, q_link[:-1], link[:-1], price_combination, user)]
    
    def aggregated_regret(self, price_combination):
        """ Method that compute the expected regret related to the prices compbination passed to the function"""
        regret = 0

        for user_cat in self.users:
            i = 1
            j = 0
            user_regret = 0
            for product in self.products:
                alpha_i = user_cat.alphas[i]
                i = i+1
                # the regret is weighted to the mean probability of having a client of a specific user category
                user_regret += alpha_i * self.exp_return(product, {}, [0], [Product([], -1, "null", [], price_combination, user_cat)])
            
            regret += self.user_cat_prob[j] * user_regret
        
        return regret

    def optimal_regret(self):
        """ This method explores all the possible combination with a brute force approac to determine which is the price combination
            that returns the highest expected regret. It returns both the optimal price combination and optimal expected regret"""
            
        optimal_combination = [0, 0, 0, 0, 0]
        regret_max = 0
        regret = 0
        
        # enumerate all possible combinations of prices (4^5, 1024)
        possible_combinations = []

        # TODO: PENSARE UN MODO PIU' INTELLIGENTE!
        for i1 in range(4):
            for i2 in range(4):
                for i3 in range(4):
                    for i4 in range(4):
                        for i5 in range(4):
                            possible_combinations.append([i1, i2, i3, i4, i5])

        for price_combination in possible_combinations:       
            # compute regret for the price combination considered
            regret = self.aggregated_regret(price_combination)
            
            # update if actual regret is greater than best past regret
            if regret > regret_max:
                regret_max = regret
                optimal_combination = price_combination.copy()

        return regret_max, optimal_combination

    def user_profit(self, user, price_combination, product_index):
        # passo una price_combination che passo dal main e un product index
        margin = 0.
        if ((not(user.buy(price_combination[product_index])) or len(user.visited_products)==5)):
            return margin
        #ho comprato e calcolo quanto ho guadagnato
        margin = price_combination[product_index] * user.get_prod_number()
        """The margin of the user is updated recursively every time he proceeds with a purchase, considering the margin of 
           that product and the number of items bought by the user (random number)"""
        #GET THE PRODUCT FROM THE DICT -> POSSO FARLI DIVENTARE DEI METODI
        first_secondary = self.products[self.Secondary_dict.get(self.products[product_index].name)[0]]
        # TODO: i collegamenti tra i diversi oggetti sono fissi o tipici per classe di utente?
        second_secondary = self.products[self.Secondary_dict.get(self.products[product_index].name)[1]]
        """To simulate the random behaviour of the user we sample from a random distribution and we use it to evaluate whether
           an event has occurred or not. """
        first_click = (np.random.uniform() < user.probabilities[
            self.products[product_index].label, first_secondary.label])
        second_click = np.random.uniform() < self.lambda_q * user.probabilities[
            self.products[product_index].label, second_secondary.label]
        # clicko sul primo e non l'ho ancora visitato
        if first_click and first_secondary not in user.visited_products:
            user.visited_products.append(first_secondary)  # add visited product to list
            return margin + self.user_profit(user, price_combination, first_secondary.label)
        #click sul secondo e non l'ho ancora visitato
        if second_click and second_secondary not in user.visited_products:
            user.visited_products.append(second_secondary)  # add visited product to list
            return margin + self.user_profit(user, price_combination, second_secondary.label)
        return margin



