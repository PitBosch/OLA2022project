from WebPage import *


class Environment:
    """Class containing all the informations that characterize the problem, from the classes of users to the list of available
       products. """

    def __init__(self, users: [UserCat], products: [Product]
                 #product_2_price
                 ):
        self.users = users
        # List of available products: each of them has available the information of its position in the list -> attribute label
        self.products = products
        # Dict connecting to each product the position (with respect to the list of possible prices) of the chosen price
        #self.product_2_price = product_2_price
##praticamente se non ho capito male dovrei creare 5 dict-> 1 per ogni prodotto
    def execute(self, user, links, lambda_prob, products):
        """Method which simulates the entire interaction (considering even the case in which the user doesn't visit the website)
           of a user with our infrastructure. It returns the cumulative amount of margin generated by this interaction. """
        page_kind = user.start_event() #Ã¨ il draw dalla multinomial per capire su che pagina attero tenendo in considerazione gli alpha
        if page_kind != 0:
            user.probabilities[:, page_kind-1] = 0
            #selected_price=self.products[page_kind].prices[self.products[page_kind].label]
            selected_price=self.products[page_kind-1].get_selected_price()
            #selected_price = self.product_2_price.get(self.products[page_kind].label)
            wp = WebPage(self.products[page_kind-1], user)
            return wp.interact(links, products,lambda_prob, selected_price)
        return 0 #mi sembra sia necessario aggiungere anche un return 0 a execute, altrimenti non restituisce niente o mi sbaglio?

    def simulate_day(self, users_number, users_probs, links, lambda_prob):
        """Method which simulates the usage of our website into an entire working day. Each day the alphas of each class of users
           are updated according to a Dirichlet distribution"""

        for user in self.users:
            user.generate_alphas()

        daily_profit = 0
        for i in range(users_number):
            user_kind = np.random.choice([0,1,2], p=users_probs) #selezioniamo a quale categoria appartiene il nostro utente
            probabilities = self.users[user_kind].probabilities.copy()

            # The class of the user is sampled from a multinomial depending on the known proportions
            daily_profit += self.execute(self.users[user_kind], links, lambda_prob, self.products)
            self.users[user_kind].restore(probabilities)

        self.update_prices()

    def update_prices(self):
        print(0)  # TODO: pensare a come effettuare l'aggiornamento dei pesi al termine di ciascuna giornata
