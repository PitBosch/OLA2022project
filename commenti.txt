- Environment.py
    update.prices() non penso abbia senso definirlo all'interno dell'Environment, perchè dipende dall'algoritmo che stiamo
    utilizzando per l'ottimizzazione. Nella mia testa l'Environment è solo una scatola nera che simula le interazioni del
    sito in un giorno e che deve sapere qual è l'optimal regret.

    Manca da implementare quindi un metodo per ricavare l'optimal regret

- UserCat.py
    Con Bosca e Elisa ci eravamo confrontati sul reservation price, oltre a trovare sensata una diminuzione rispetto agli acquisti
    effettuati (che però secondo me rimane inattuabile o comunque di difficile implementazione pratica e teorica) avevamo pensato
    di rendere randomico il valore del reservation price per ogni utente della simulazione. Per la distribuzione si pensava una
    gamma/gamma troncata che avesse dei parametri fissati per classe di utente e concordi col il tipo di utente (e.g. utenti 
    giovani e ignoranti avranno una distribuzione di reservation price concentrata su valori bassi)

    Gestione delle Probabilities: secondo me è brutto fare una copia dell'originale e poi ributtarcela dentro. Vedendo anche i 
    problemi che ci sono in WebPage.py per la gestione delle Probabilities ha senso pensare a un modo più sensato di farlo.
    Secondo me la cosa migliore è lasciare le probabilities fisse e aggiungere nella simulazione una lista con i primary esplorati
    e un IF secondary in lista(primary esplorati) NON CLICCO

- Product.py
    I secondary poduct mostrati all'acquisto di un primary product sono fissi, si può considerare di aggiungere la lista dei 
    secondary associati alle strutture dati di questa classe. Se no la dict[Product] va benissimo.

- WebPage.py
    interact() + struttura generale : così come è implementato il tutto io continuo a creare oggetti WebPage e oggetti User.
    Pensavo se avesse senso avere una classe WebPage: non conviene implementare semplicemente il metodo interact nell'environment?
    Nella mia testa prenderebbe in ingresso:
        - Primary product (in cui abbiamo messo anche i link ai secondary)
        - matrice della probabilities (su cui può fare quello che vuole)
        - reservation price
        - lambda
        - Combinaizione dei prezzi che si sta esplorando

    Secondo me poi ha senso organizzare la struttura ricorsiva con dei return margin + interact(....) in modo da non dover creare 
    continuamente degli oggetti della classe user
    
    
    BOSCA
    Una roba che io non capisco invece è la gestione degli alpha perchè devo passarli a ogni classe di utenti? quando poi vado a
    riaggiornarli tramite una dirichlet? Se faccio sta roba non continuano a concentrarsi solo su un particolare valore?
    Poisson lambda non dipende dal prodotto?


FARE:
- mettere lista di oggetti già visitati + sistemare le probabilities
- cambiare struttura della visita (meccanismo gerarchico dei prodotti visitati)
- aggiungere meccanismo di sampling per il reservation price di ogni utente data la distribuzione

ANDRE:
- In tutte le classi con funzioni di probabilità da cui estraiamo penso sia meglio avere degli "oggetti random generator" con seed 
    impostabile per avere la replicabilità degli esperimenti e non rischiare di estrarre sempre le stesse cose. Può aver senso anche
    avere degli oggetti distribuzione in modo da non dovere avere più metodi che creano la stessa cosa.



ANDRE E BOSCA
-Togliamo product 2 price B
-Aggiungere struttura links in environment B(secondarydict- associazione primary-secondary perchè deve essere fissato,
 ce lo dice la consegna)
-USercatprob meglio metterlo nella usercat A
-LINEA 36 USER PROBS LINKS E LAMBDA DA TOGLIERE
-struttura dati primary history if compro if compro sull'altro -> rifare seguendo la logica del exp_return
-Gestire bene le simulazioni -> gestire bene tutto quello che è generato randomicamente
-il margin dato che continuiamo ad azzerarlo ha senso se lo lasciamo come variabile dello scope webpage ma vedi sopra.
-Togliamo margin da usercat, non è relativo alla categoria utente ma è specifico del path/simulazione seguit*
-


Teoria:
-Abbiamo 1024 combinazioni di prezzi e dobbiamo trovare quella giusta.
-Algoritmo-> 5 MAB da 4 braccia  (Assunzione indipendenza dei prezzi->non è vero Pro: algo comodo contro: sbagliato,
 NB:salvo profitto per prodotto